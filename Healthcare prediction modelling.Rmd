---
title: "Theming with bslib and thematic"
output: 
  html_document:
    code_folding: hide
    toc: true
    theme:
      bg: "#F9F7F7"
      fg: "#112D4E"
      primary: "#DBE2EF"
      secondary: "#3F72AF"
      base_font:
        google: Prompt
      heading_font:
        google: Proza Libre
---

```{r setup, include=FALSE}
if (!require(pacman)) {install.packages("pacman")}

pacman::p_load(plyr, kableExtra, rstatix, rstatix, tidyverse)


# Import data
healthcare <- read_csv("Hospitals_Train.csv")


```



# Introduction 

This is my attempt at finding the best tree model for the healthcare prediction data that was analyzed by [`ALIA107`](https://www.kaggle.com/code/bvc5283/healthcare-prediction/notebook) on kaggle. 
Data was downloaded from here: https://github.com/HannahHan3/758T_PredictiveModeling

I will more or less try to reproduce the same effects as the user above, but refining the code, reporting language, and overall presentation of tables and figures as to make it more appealing to a general user.
I will also expand the analysis when seen appropriate.

The goal is to predict whether a discharged patient will return to the hospital within 30 days.




# Infrastructure

Below I create a set of vectors that will serve as basic parameters mostly for producing tables and plots.
Further, here I will set up all self-created functions.
All of this helps with making the code shorter and cleaner.

## Plots


### Color Palette

```{r}
# https://colorhunt.co/palette/f9f7f7dbe2ef3f72af112d4e
#F9F7F7
#112D4E
#DBE2EF
#3F72AF

colors <- c(
  "#FF9843",
  "#FFDD95",
  "#86A7FC",
  "#3468C0"
)


thematic::thematic_rmd(font = "auto", qualitative = colors)




```



## Tables


```{r}

own_table <- function(x) {
  x %>% 
    kable() %>% 
    kable_minimal(lightable_options = "hover")
}

```




# Data cleaning

Let's take a look at the basic structure of the dataset.

```{r}

glimpse(healthcare)


```

The `read_csv` function, as opposed to `read.csv`, automatically ascribes `NA` to empty values.


```{r}

dimen <- dim(healthcare)
dimen

```
The raw dataset contains `r dimen[1]` obsevations with `r dimen[2]` variables.

In order to ease coding the names of all variables are turned to lowercase.

```{r}

healthcare <- healthcare %>% 
  rename_with(~str_to_lower(.), everything())

```



## Missing data


```{r}
healthcare %>% 
  summarise(
    across(everything(), list(
      number = ~sum(is.na(.)), 
      percent = ~mean(is.na(.)) 
      )
    )
  ) %>% 
  pivot_longer(
    everything(), 
    names_pattern = "(.*)_(.*)",
    names_to = c("Variable", "Statistic"),
    values_to = "value"
    ) %>% 
  pivot_wider(names_from = Statistic, values_from = value) %>% 
  mutate(percent = round(percent * 100, 1)) %>% 
  arrange(desc(percent)) %>% 
  filter(number != 0) -> missing

missing2 <- missing %>% 
  filter(percent > 10)

missing %>% 
  own_table
```


There are `r nrow(missing)` variables with missing data. However, only `r nrow(missing2)` have missing values at a level of more than 10%.

We can check, if there is any pattern in missing values in relation to to the `return` (DV) variable.


```{r}

missing_filt <- missing %>% 
  pull(Variable)


healthcare %>% 
  select(return, missing_filt) %>% 
  mutate(across(-return, ~if_else(is.na(.), "Missing", "Non-missing"))) %>% 
  pivot_longer(-return) %>% 
  nest(.by = name) %>% 
  mutate(
    freq_table = map(data, freq_table, value, return)
  ) %>% 
  select(-data) %>% 
  unnest() %>% 
  ggplot(aes(value, prop, fill = return)) +
  geom_bar(stat = "identity") +
  facet_wrap(~name)


```


Differences in proportions of those who returned were observed in all variables that had missing values.
Including them could improve the model.
Therefore, in the case of character variables, `NA` will be coded as *"Missing"*.



```{r}
# Adding missing as a string value
healthcare <- healthcare %>% 
  mutate(
    across(where(is.character), ~replace_na(., "Missing")) 
  ) %>% 
  select(-c(consult_in_ed, index)) # Exclude the numerical variable with mostly missing values and index
```




## Qualitative values

### Unique values

Checking what character vectors represent by inspecting unique values.

```{r}

healthcare %>% 
  select(where(is.character)) %>% 
  map(unique) %>% 
  keep(~length(.) < 50) %>% 
  {
    by_length <- lengths(.) %>% 
      order()
    .[by_length]
    }


```
Variables like Race or Ethnicity have two values that essentially mean the same thing - *"Declined to answer"* and *Unknown*". Both will be transformed to missing values.

The **DC** stands for discharge, while **ED** for emergency department. Both consist of a substantial number of unique values. Using them in at least some of the models (e.g. regressions) would be highly penalized, because of a large number of predictors. Further, if we strive for higher interpretability, a simpler model is preferred. 
Therefore, we will simplify those variables to a smaller number of levels. This will also include `race` and `financial_class`, as they also have above 10 levels.

```{r}
healthcare %>% 
  select(financial_class, ed_result, dc_result, race) %>% 
  pivot_longer(everything()) %>% 
  nest(.by = name) %>% 
  mutate(freq = map(data, freq_table, value)) %>% 
  select(-data) %>% 
  unnest() %>% 
  arrange(name, desc(prop)) %>% 
  filter(prop > 1) %>% 
  own_table()

```


Based on the proportions, `dc_result` will be recoded to a variable with only two values, as the majority of the patients belonged to one category. The `ed_result` and `financial_class` variables have a more varied distribution and will be lumped up to the category with 5% of observations. In the latter case a more theoretically-oriented approach could be implemented, but it would require a higher domain-knowledge. `race` will be divided to three categories:
*"Black or African American"*, 
*"White"* and 
*"Other"*.


```{r}
# Check if there are other, similarly formulated values as "home or self care"
healthcare$dc_result %>% 
  unique() %>% 
  str_subset("[hH]ome|[sS]elf")
  

```
"Home Health Care Svc" sounds similar to "Home or Self Care". However, as the distinction is not obvious and I lack proper theoretical background, it will be left as it is.




```{r}
healthcare <- healthcare %>% 
  mutate(
    across(c(ed_result, financial_class), ~fct_lump_prop(., 0.05)),
    race = fct_lump(race, 2),
    dc_result = fct_lump(dc_result, 1)
  ) 
  


```




Variable `acuity_arr` has a suspected value *"5 Purple"*, as it does not make sense in the context of the remaining values.

```{r}
healthcare %>% 
  count(acuity_arr) %>% 
  own_table()


```

As there is only one observation with such value, it can be safely ignored as `NA`.

```{r}


# Transforming remaining character vectors to factors
healthcare2 <- healthcare %>% 
  mutate(
    acuity_arr = mapvalues(acuity_arr, "5 Purple", "Missing" ),
    acuity_arr = factor(acuity_arr) %>% fct_relabel(~str_replace(., "[0-9]-", "")),
    across(c(race, ethnicity), ~plyr::mapvalues(
      .,  
      from = c( "Declined to Answer","Unknown"),
      to = c("Missing", "Missing")
      )
    ),
    across(
      c(hospital, gender, race, ethnicity, diagnosis, return, financial_class, admit_result),
      ~as.factor(.)
      ),
    across(c(risk, severity), ~factor(., levels = c("Minor","Moderate", "Major", "Extreme", "Missing"))),
    across(
      c(race, financial_class, admit_result, ethnicity), 
      ~fct_relevel(., "Missing", "Other", after = Inf)) # Move "other" to the end
  ) 





```

## Numerical variables



```{r}
# Inspect first 10 unique elements 
healthcare2 %>% 
  select(where(is.numeric)) %>% 
  map(unique) %>% 
  map(function(x) {x[1:10] %>% keep(!is.na(.))}) 

```

Three variables are binary which suggests that they are of *occured* / *not occured* nature and as such are categorical. They will be transformed to factor variables.

Six of the numerical variables are date / datetime objects.
They could be treated as either categorical or continuous variables, depending on the theoretical and methodological backgrounds. In this case, as our outcome variable is binary and there is no apparent linear or continuity aspect to it in terms of passing time, it is more methodologically sound to treat them as factors, whereby the model would assess the effect of each time-point separately. However, they will be first explored.


```{r}
# Transforming selected numerical columns to factors
healthcare2 <- healthcare2 %>% 
  mutate(
    across(c(same_day, consult_order, consult_charge), ~as.factor(.)),
    across(matches("weekday|month|hour"), ~as.factor(.))
    )



```




# EDA

## Return - the outcome variable


```{r}
healthcare2 %>% 
  freq_table(return) %>% 
  own_table()

```

For every three patients who did not return, there was one who did.


## Analysis of qualitative variables

```{r fig.asp=1.5}

# Pivot data and create a faceted bar plot
healthcare2 %>% 
  select(return, where(is.factor)) %>% 
  pivot_longer(everything()) %>% 
  nest(.by = name) %>% 
  mutate(freq = map(data, freq_table, value)) %>% 
  unnest(.by = freq) %>% 
  mutate(name = factor(name) %>% fct_relevel("return", after = Inf)) %>% # Show outcome variable as last
  ggplot(aes(value, prop)) +
  geom_bar(stat = "identity") +
  facet_wrap(~name, scales = "free", ncol = 2) +
  coord_flip()


```
Except what was already learned while inspecting variables with missing values, we can see an equal distribution of gender and the hospital from which the data comes. Interestingly, there is a reversed distribution of diagnosis to return. Theoretically, it would make sense for the diagnosis to be a strong predictor of return, as knowing the nature of the disease would allow for proper and quicker treatment followed with a resolution. 



```{r fig.asp=1.5}

# Pivot data and create a faceted bar plot of all string variables against return
healthcare2 %>% 
  select(return, where(is.factor), -matches("hour|month|weekday")) %>% 
  mutate( return = fct_rev(return)) %>% 
  pivot_longer(-return) %>% 
  nest(.by = name) %>% 
  mutate(
    freq = map(data, freq_table, value, return)
    ) %>% 
  unnest(.by = freq) %>% 
  ggplot(aes(value, prop, fill = return)) +
  geom_bar(stat = "identity") +
  facet_wrap(~name, scales = "free", ncol = 2) +
  coord_flip()


```
Diagnosis, or its lack to be more specific, indeed seems to be a predictor of return. However, the relationship is not as strong as anticipated. 

Regardless of the hospital, the proportion of those who returned within 30 days to the hospital was the same. 

Interestingly, in almost all variables that had `NA`, missing value was associated with a higher chance of return.



## Exploration of quantitative variables

### Distribution of age and diagnosis details

```{r}

healthcare2 %>% 
  select(where(is.numeric)) %>% 
  pivot_longer(everything()) %>% 
  ggplot(aes(value)) +
  geom_histogram() +
  facet_wrap(~name, scales = "free")
  


```

### Distribution of date / time variables

```{r}

healthcare2 %>% 
  select(matches("hour|month|weekday")) %>% 
  pivot_longer(everything()) %>% 
  count(name, value) %>% 
  mutate(value = factor(value, levels = 0:23)) %>% # Set 0 as the starting point
  ggplot(aes(value, n)) +
  geom_bar(stat = "identity") +
  facet_wrap(~name, scales = "free", ncol = 2) 
  

```
The arrivals and departures were most frequent during late afteroon and late evening hours and least frequent during morning.

Interestingly, their corresponding distributions look almost identical.

```{r}
# Identify different values between hour variables
setdiff(healthcare2$hour_arr, healthcare2$hour_dep)


```
Indeed, they are identical. This could mean that the time between their arrival and, following discharge, departure was always shorter than one hour. However, a more plausible explanation is that there is a methodological error in data preparation, as one would expect at several instances of patients who arrived at the end of a given hour and left at the onset of the next hour.

Regardless of the true reason, a duplicate should be removed to avoid multicollinearity as well as a general methodological misunderstanding. This also includes the month and weekday variables.


```{r}
healthcare3 <- healthcare2 %>% 
  select(-ends_with("dep")) %>% 
  rename_with(~str_replace(., "_arr", ""), matches("month|hour|weekday"))

```




```{r}



healthcare3 %>% 
  select(weekday, hour, month, return) %>% 
  pivot_longer(-return) %>% 
  nest(.by = name) %>% 
  mutate(freq = map(data, freq_table, value, return)) %>% 
  unnest(.by = freq) %>% 
  mutate(value = factor(value, levels = 0:24)) %>%  # Set 0 as the starting point for the hour variable
  filter(return == "Yes")  %>% 
  ggplot(aes(value, prop, group = 1)) +
  geom_bar(stat = "identity") +
  geom_line(size = 1, color = colors[2]) +
  facet_wrap(~name, scales = "free", ncol = 2)
    


```

In the case of hour there is a small 





Co zrobić z uporządkowaniem zmiennych numerycznych, które tak naprawdę są jakościowe?

Co zrobić ze zmiennymi czasowymi?