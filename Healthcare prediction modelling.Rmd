---
title: "Theming with bslib and thematic"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float: 
      collapsed: false
      smooth_scroll: true
    theme:
      bg: "#F9F7F7"
      fg: "#112D4E"
      primary: "#DBE2EF"
      secondary: "#3F72AF"
      base_font:
        google: Prompt
      heading_font:
        google: Proza Libre
---

```{r setup, include=FALSE}
if (!require(pacman)) {install.packages("pacman")}

pacman::p_load(plyr, kableExtra, rstatix, rstatix, tidyverse)


# Import data
healthcare <- read_csv("Hospitals_Train.csv")


```



# Introduction 

This is my attempt at finding the best tree model for the healthcare prediction data that was analyzed by [`ALIA107`](https://www.kaggle.com/code/bvc5283/healthcare-prediction/notebook) on kaggle. 
Data was downloaded from here: https://github.com/HannahHan3/758T_PredictiveModeling

I will more or less try to reproduce the same effects as the user above, but refining the code, reporting language, and overall presentation of tables and figures as to make it more appealing to a general user.
I will also expand the analysis when seen appropriate.

The goal is to predict whether a discharged patient will return to the hospital within 30 days.




# Infrastructure

Below I create a set of vectors that will serve as basic parameters mostly for producing tables and plots.
Further, here I will set up all self-created functions.
All of this helps with making the code shorter and cleaner.

## Plots


### Color Palette

```{r}
# https://colorhunt.co/palette/f9f7f7dbe2ef3f72af112d4e
#F9F7F7
#112D4E
#DBE2EF
#3F72AF

colors <- c(
  "#FF9843",
  "#FFDD95",
  "#86A7FC",
  "#3468C0"
)


thematic::thematic_rmd(font = "auto", qualitative = colors)




```



## Tables


```{r}

own_table <- function(x) {
  x %>% 
    kable() %>% 
    kable_minimal(lightable_options = "hover")
}

```




# Data cleaning

Let's take a look at the basic structure of the dataset.

```{r}

glimpse(healthcare)


```

The `read_csv` function, as opposed to `read.csv`, automatically ascribes `NA` to empty values.


```{r}

dimen <- dim(healthcare)
dimen

```
The raw dataset contains `r dimen[1]` observations with `r dimen[2]` variables.

In order to ease coding, the names of all variables are converted to lowercase.

```{r}

healthcare <- healthcare %>% 
  rename_with(~str_to_lower(.), everything())

```



## Missing data


```{r}
healthcare %>% 
  summarise(
    across(everything(), list(
      number = ~sum(is.na(.)), 
      percent = ~mean(is.na(.)) 
      )
    )
  ) %>% 
  pivot_longer(
    everything(), 
    names_pattern = "(.*)_(.*)",
    names_to = c("Variable", "Statistic"),
    values_to = "value"
    ) %>% 
  pivot_wider(names_from = Statistic, values_from = value) %>% 
  mutate(percent = round(percent * 100, 1)) %>% 
  arrange(desc(percent)) %>% 
  filter(number != 0) -> missing

missing2 <- missing %>% 
  filter(percent > 10)

missing %>% 
  own_table
```


There are `r nrow(missing)` variables with missing data. However, only `r nrow(missing2)` have a noticeably high number of missing values, while the remaining stay below a level of 10%.

We can check, if there is any pattern in missing values in relation to to the `return` (DV) variable.


```{r}

missing_filt <- missing %>% 
  pull(Variable)


healthcare %>% 
  select(return, all_of(missing_filt)) %>% 
  mutate(across(-return, ~if_else(is.na(.), "Missing", "Non-missing"))) %>% 
  pivot_longer(-return) %>% 
  nest(.by = name) %>% 
  mutate(
    freq_table = map(data, freq_table, value, return)
  ) %>% 
  select(-data) %>% 
  unnest() %>% 
  ggplot(aes(value, prop, fill = return)) +
  geom_bar(stat = "identity") +
  facet_wrap(~name)


```


Differences in the proportions of those who returned were observed across variables that had missing values. Therefore, including information about missing values could benefit the model. Consequently, for character variables, `NA` will be coded as *'Missing'*.

As `consult_in_ed` is a numerical variable, it is methodologically not possible to include a character value *'Missing'*. However, let's inspect its unique values.

```{r}

unique(healthcare$consult_in_ed)
  

```
This probably means that 1 represents the occurence of consultation, while `NA` represents lack of such occurence.
However, having no such knowledge, it is safer to code `NA` as *'Missing'*.





```{r}
# Adding missing as a string value
healthcare <- healthcare %>% 
  mutate(
    across(where(is.character), ~replace_na(., "Missing")),
    consult_in_ed = mapvalues(consult_in_ed, c(1, NA), c("Consulted", "Missing")),
    consult_in_ed = factor(consult_in_ed)
  ) 
  
```




## Categorical variables


### Large qualitative variables


```{r}

qualitatives <- healthcare %>% 
  select(where(is.character)) %>% 
  map(unique) %>% 
  keep(~length(.) > 50) %>% 
  map(length) %>%  
  enframe() %>% 
  unnest()
  
qualitatives %>% 
  own_table()
  

```

One character variable, namely, `r qualitatives$name[1]` has `r qualitatives$value[1]` unique values.
However, based on the name, this seems to be a numerical variable.


```{r}
set.seed(1)
healthcare %>% 
  slice_sample(n = 20) %>% 
  pull(charges)


```


```{r}
healthcare %>% 
  mutate(
    charges2 = as.double(charges)
  ) %>% 
  filter(is.na(charges2)) %>% 
  select(charges, charges2) %>% 
  own_table()
```

A small portion of the observations for that variable has uninterpretable values. Nothing to worry about


```{r}
# Apply modification of the charge variable to the dataset
healthcare <- healthcare %>% 
  mutate(
    charges = as.double(charges)
  ) %>% 
  drop_na(charges)

```



### Unique values

Checking what character vectors represent by inspecting unique values.

```{r}

healthcare %>% 
  select(where(is.character)) %>% 
  map(unique) %>% 
  keep(~length(.) < 50) %>% # Exclude potential qualitative variables 
  {
    by_length <- lengths(.) %>% 
      order()
    .[by_length]
    }


```
Variables like Race or Ethnicity have two values that essentially mean the same thing - *"Declined to answer"* and *Unknown*". Both will be transformed to missing values.

The **DC** stands for discharge, while **ED** for emergency department. Both consist of a substantial number of unique values. Using them in at least some of the models (e.g. regressions) would be highly penalized, because of a large number of predictors. Further, if we strive for higher interpretability, a simpler model is preferred. 
Therefore, we will simplify those variables to a smaller number of levels. This will also include `race` and `financial_class`, as they also have above 10 levels.

```{r}
healthcare %>% 
  select(financial_class, ed_result, dc_result, race) %>% 
  pivot_longer(everything()) %>% 
  nest(.by = name) %>% 
  mutate(freq = map(data, freq_table, value)) %>% 
  select(-data) %>% 
  unnest() %>% 
  arrange(name, desc(prop)) %>% 
  filter(prop > 1) %>% 
  own_table()

```


Based on the proportions, `dc_result` will be recoded to a variable with only two values, as the majority of the patients belonged to one category. The `ed_result` and `financial_class` variables have a more varied distribution and will be lumped up to the category with 5% of observations. In the latter case a more theoretically-oriented approach could be implemented, but it would require a higher domain-knowledge. `race` will be divided to three categories:
*"Black or African American"*, 
*"White"* and 
*"Other"*.


```{r}
# Check if there are other, similarly formulated values as "home or self care"
healthcare$dc_result %>% 
  unique() %>% 
  str_subset("[hH]ome|[sS]elf")
  

```
"Home Health Care Svc" sounds similar to "Home or Self Care". However, as the distinction is not obvious and I lack proper theoretical background, it will be left as it is.




```{r}
healthcare <- healthcare %>% 
  mutate(
    across(c(ed_result, financial_class), ~fct_lump_prop(., 0.05)),
    race = fct_lump(race, 2),
    dc_result = fct_lump(dc_result, 1)
  ) 
  


```




Variable `acuity_arr` has a suspected value *"5 Purple"*, as it does not make sense in the context of the remaining values.

```{r}
healthcare %>% 
  count(acuity_arr) %>% 
  own_table()


```

As there is only one observation with such value, it can be safely ignored as `NA`.

```{r}


# Transforming remaining character vectors to factors
healthcare2 <- healthcare %>% 
  mutate(
    acuity_arr = mapvalues(acuity_arr, "5 Purple", "Missing" ),
    acuity_arr = factor(acuity_arr) %>% fct_relabel(~str_replace(., "[0-9]-", "")),
    across(c(race, ethnicity), ~plyr::mapvalues(
      .,  
      from = c( "Declined to Answer","Unknown"),
      to = c("Missing", "Missing")
      )
    ),
    across(
      c(hospital, gender, race, ethnicity, diagnosis, return, financial_class, admit_result),
      ~as.factor(.)
      ),
    across(c(risk, severity), ~factor(., levels = c("Minor","Moderate", "Major", "Extreme", "Missing"))),
    across(
      c(race, financial_class, admit_result, ethnicity), 
      ~fct_relevel(., "Missing", "Other", after = Inf)) # Move "other" to the end
  ) 





```



## Numerical variables



```{r}
# Inspect the 10 first unique elements 
healthcare2 %>% 
  select(where(is.numeric)) %>% 
  map(unique) %>% 
  map(function(x) {x[1:10] %>% keep(!is.na(.))}) 

```

Three variables are binary which suggests that they are of *occured* / *not occured* nature and as such are categorical. They will be transformed to factor variables.

Six of the numerical variables are date / datetime objects.
They could be treated as either categorical or continuous variables, depending on the theoretical and methodological backgrounds. In this case, as our outcome variable is binary and there is no apparent linear or continuity aspect to it in terms of passing time, it is more methodologically sound to treat them as factors, whereby the model would assess the effect of each time-point separately. 
This decision will be further explored as part of EDA.


```{r}
# Transforming selected numerical columns to factors
healthcare2 <- healthcare2 %>% 
  mutate(
    across(c(same_day, consult_order, consult_charge), ~as.factor(.)),
    across(matches("weekday|month|hour"), ~as.factor(.))
    )



```




# EDA

## Return - the outcome variable


```{r}
healthcare2 %>% 
  freq_table(return) %>% 
  own_table()

```

For every three patients who did not return, there was one who did.


## Exploration of the categorical variables

```{r fig.asp=1.5}

# Pivot data and create a faceted bar plot
healthcare2 %>% 
  select(return, where(is.factor), -matches("hour|month|weekday")) %>% 
  pivot_longer(everything()) %>% 
  nest(.by = name) %>% 
  mutate(freq = map(data, freq_table, value)) %>% 
  unnest(.by = freq) %>% 
  mutate(name = factor(name) %>% fct_relevel("return", after = Inf)) %>% # Show outcome variable as last
  ggplot(aes(value, prop)) +
  geom_bar(stat = "identity") +
  facet_wrap(~name, scales = "free", ncol = 3) +
  coord_flip()


```
Except what was already learned while inspecting variables with missing values, we can see an equal distribution of gender and the hospital from which the data comes. Interestingly, there is a reversed distribution of diagnosis to return. Theoretically, it would make sense for the diagnosis to be a strong predictor of return, as knowing the nature of the disease would allow for proper and quicker treatment followed with a resolution. 



```{r fig.asp=1.5}

# Pivot data and create a faceted bar plot of all string variables against return
healthcare2 %>% 
  select(return, where(is.factor), -matches("hour|month|weekday")) %>% 
  mutate( return = fct_rev(return)) %>% 
  pivot_longer(-return) %>% 
  nest(.by = name) %>% 
  mutate(
    freq = map(data, freq_table, value, return)
    ) %>% 
  unnest(.by = freq) %>% 
  ggplot(aes(value, prop, fill = return)) +
  geom_bar(stat = "identity") +
  facet_wrap(~name, scales = "free", ncol = 2) +
  coord_flip()


```
Diagnosis, or its lack to be more specific, indeed seems to be a predictor of return. However, the relationship is not as strong as anticipated. 

Regardless of the hospital, the proportion of those who returned within 30 days to the hospital was the same. 

Interestingly, in almost all variables that had `NA`, missing value was associated with a higher chance of return.



## Exploration of quantitative variables

### Descriptive statistics and distribution of age, charges, and diagnosis details


```{r}

descriptives <- healthcare2 %>% 
  get_summary_stats(type = "common") 

# Extract stats for an automated describing 
descriptives2 <- descriptives %>% 
  nest(.by = variable) %>% 
  mutate(data = map(data, unlist)) %>% 
  pull(data) %>% 
  set_names(descriptives$variable)

descriptives %>% 
  own_table()

```


People were between `r descriptives2$age[2]` and `r descriptives2$age[3]` years old with a mean of `r descriptives2$age[6]`.

Charges encompassed from `r descriptives2$charges[2]` to `r descriptives2$charges[3]`. As the mean (*M* = `r descriptives2$charges[6]`) was substantially bigger compared to the median `r descriptives2$charges[4]` this suggests a large number of extreme values and that the distribution was rightly skewed.




```{r}

healthcare2 %>% 
  select(where(is.numeric)) %>% 
  pivot_longer(everything()) %>% 
  ggplot(aes(value)) +
  geom_histogram() +
  facet_wrap(~name, scales = "free") 
  


```

Most of the patients were either in their early adulthood or middle-age.




```{r}

charges_sep <- healthcare2 %>% 
  mutate(charges_z = scale(charges)) %>% 
  {
    charges_cleaner <- filter(., abs(charges_z) <= 2)
    charges_extreme <- filter(., abs(charges_z) > 2)
    list(charges_extreme, charges_cleaner) %>% 
      set_names(c("charges_cleaner", "charges_extreme"))
  }


charges_sep$charges_cleaner %>% 
  ggplot(aes(charges)) +
  geom_histogram()

charges_sep$charges_extreme %>% 
  ggplot(aes(charges)) +
  geom_histogram()

```




```{r}

healthcare2 %>% 
  select(where(is.numeric), return) %>% 
  pivot_longer(-return) %>% 
  ggplot(aes(value, color = return)) +
  geom_density() +
  facet_wrap(~name, scales = "free")

```
Being between 50 and 60 years old was associated with a higher chance of return.
The relationship is not linear.



## Exploration of the date / time variables

```{r}

healthcare2 %>% 
  select(matches("hour|month|weekday")) %>% 
  pivot_longer(everything()) %>% 
  count(name, value) %>% 
  mutate(value = factor(value, levels = 0:23)) %>% # Set 0 as the starting point (hour variable)
  ggplot(aes(value, n)) +
  geom_bar(stat = "identity") +
  facet_wrap(~name, scales = "free", ncol = 2) 
  

```
The arrivals and departures were most frequent during late afteroon and late evening hours and least frequent during morning. 
The months with somewhat higher departures and arrivals were January (possibly associated with the New Year's Eve) and March to July. There is no data for October.

Interestingly, the corresponding distributions of arrivals and departures in pair of variables look almost identical.

```{r}
# Identify different values between hour variables
setdiff(healthcare2$hour_arr, healthcare2$hour_dep)


```
Indeed, they are identical. This could mean that the time between their arrival and, following discharge, departure was always shorter than one hour. However, a more plausible explanation is that there is a methodological error in data preparation, as one would expect at several instances of patients who arrived at the end of a given hour and left at the onset of the next hour.


WHAT TO DO ABOUT THE FEW NOT DUPLICATED CASES BELOW?
LOOKS LIKE THERE IS SOME INCONSISTENCY IN DATA

```{r}

healthcare2 %>% 
  filter(same_day == 0) %>% 
  select(matches("month|weekday|hour")) %>% 
  pivot_longer(
    everything(), 
    names_pattern = "(.+)_(.+)", 
    names_to = c("date", "type"), 
    values_to = "value"
    ) %>% 
  group_by(type) %>% 
  mutate(id = row_number()) %>% 
  pivot_wider(names_from = "type", values_from = "value") %>% 
  mutate(
    duplicated = arr == dep
  ) %>% 
  filter(!duplicated)


```


Regardless of the true reason, a duplicate should be removed to avoid multicollinearity. This also includes the month and weekday variables, as it follows that they too have to be duplicated.


```{r}
healthcare3 <- healthcare2 %>% 
  select(-ends_with("dep")) %>% 
  rename_with(~str_replace(., "_arr", ""), matches("month|hour|weekday"))

```


Let's see what is the distribution of returns depending on the date-time points.

```{r}



healthcare3 %>% 
  select(weekday, hour, month, return) %>% 
  pivot_longer(-return) %>% 
  nest(.by = name) %>% 
  mutate(freq = map(data, freq_table, value, return)) %>% 
  unnest(.by = freq) %>% 
  mutate(value = factor(value, levels = 0:24)) %>%  # Set 0 as the starting point for the hour variable
  filter(return == "Yes")  %>% 
  ggplot(aes(value, prop, group = 1)) +
  geom_bar(stat = "identity") +
  geom_line(color = colors[1], linewidth = 0.8) +
  facet_wrap(~name, scales = "free", ncol = 2)
    


```

The highest numbers of returns were observed from night to morning peaking in early-morning hours (between 5 and 7 a.m.). The relationship is, however, non-linear and as the daytime has a cyclic nature it's starting point is chosen arbitrarily. This, with previous considerations, reasons for operationalizing hour of the day as a categorical variable.

The rates of returns were more or less the same throughout the year with the exception of September, which was associated with noticeably lower numbers of returns. During the week, Monday was associated with somewhat higher rate of returns compared to the rest of the week. 

This speaks for reducing the number of levels such to group neighbouring levels with similar rates of returns. This will reduce the number of predictors in the final model.


```{r}

healthcare3 %>% 
  mutate(
    month = factor(month, labels = month.abb[-11]),
    weekday = factor(weekday, labels = c(
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat",
      "Sun"
    ))
  )

```



